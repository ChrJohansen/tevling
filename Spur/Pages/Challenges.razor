@page "/challenges"

<PageTitle>Spur - Challenges</PageTitle>

<h1>Challenges</h1>

<a class="btn btn-primary mb-2" href="challenges/create">Add challenge</a>

<div class="d-flex mb-2">
    <InputRadioGroup @bind-Value="ShowAllChallenges">
        <div class="form-check form-check-inline">
            <label>My challenges: <InputRadio Value="false" /></label>
        </div>
        <div class="form-check form-check-inline">
            <label>All challenges: <InputRadio Value="true" /></label>
        </div>
    </InputRadioGroup>
</div>

<div class="d-flex flex-wrap cg-3 rg-3 mb-3">
    @foreach (var challenge in ChallengeList)
    {
        <ChallengeCard AthleteId="@AthleteId" Challenge="@challenge" />
    }
</div>

<InfiniteScrollingMarker LoadMore="LoadMore">
    <LoadingTemplate>Loading...</LoadingTemplate>
</InfiniteScrollingMarker>

@inject IAuthenticationService AuthenticationService
@inject IChallengeService ChallengeService
@inject ILogger<Challenges> Logger
@code {
    private Challenge[] ChallengeList { get; set; } = [];
    private List<Challenge> _challenges = new();
    private int AthleteId { get; set; }
    private bool _showAllChallenges = true;
    private bool ShowAllChallenges
    {
        get => _showAllChallenges;
        set
        {
            _showAllChallenges = value;
            UpdateChallenges();
        }
    }

    private IDisposable? _challengeFeedSubscription;
    private int _pageSize = 10;
    private int _page = 0;

    protected override async Task OnInitializedAsync()
    {
        Athlete? athlete = await AuthenticationService.GetCurrentAthleteAsync();

        if (athlete != null)
        {
            AthleteId = athlete.Id;
            await FetchChallenges();
            SubscribeToChallengeFeed();
        }
    }

    private async Task<bool> LoadMore(CancellationToken ct = default)
    {
        int prevCount = _challenges.Count;
        _page++;
        await FetchChallenges();
        return _challenges.Count > prevCount;
    }

    private async Task FetchChallenges()
    {
        Challenge[] challenges = await ChallengeService.GetChallengesAsync(_pageSize, _page);
        AddChallenges(challenges);
    }

    private void SubscribeToChallengeFeed()
    {
        _challengeFeedSubscription = ChallengeService.GetChallengeFeed()
            .Catch<FeedUpdate<Challenge>, Exception>(err =>
            {
                Logger.LogError(err, "Error in challenge feed");
                return Observable.Throw<FeedUpdate<Challenge>>(err).Delay(TimeSpan.FromSeconds(1));
            })
            .Retry()
            .Subscribe(feed =>
            {
                switch (feed.Action)
                {
                    case FeedAction.Create:
                        AddChallenges(feed.Item);
                        break;
                    case FeedAction.Update:
                        ReplaceChallenge(feed.Item);
                        break;
                    case FeedAction.Delete:
                        RemoveChallenge(feed.Item);
                        break;
                    default:
                        throw new ArgumentOutOfRangeException("Unknown challenge feed action: " + feed.Action);
                }
            });
    }

    private void AddChallenges(params Challenge[] challenges)
    {
        _challenges.AddRange(challenges);

        UpdateChallenges();
    }

    private void ReplaceChallenge(Challenge challenge)
    {
        _challenges.RemoveAll(c => c.Id == challenge.Id);
        _challenges.Add(challenge);

        UpdateChallenges();
    }

    private void RemoveChallenge(Challenge challenge)
    {
        _challenges.RemoveAll(c => c.Id == challenge.Id);

        UpdateChallenges();
    }

    private void UpdateChallenges()
    {
        ChallengeList = _challenges
            .Where(c => ShowAllChallenges
                || (c.Athletes?.Any(athlete => athlete.Id == AthleteId) == true
                || c.CreatedById == AthleteId))
            .OrderByDescending(c => c.Start)
            .ThenBy(c => c.Title)
            .ToArray();

        InvokeAsync(StateHasChanged);
    }
}
